
% ------------------------------------------------------------------------

\chapter{B: Magma code}
\label{AppD}

In this appendix we collect various pieces
of Magma code which can be helpful in the
computations over the finite fields. First, we define the field we are working 
in, and also we define the octonion algebra
by providing the structure constants table.
\begin{verbatim}
FF<w> := GF(9); 
F3 := GF(3); 
q := 3;

F<A1,A2,A3,A4,A5,A6,A7,A8,
  B1,B2,B3,B4,B5,B6,B7,B8,
  C1,C2,C3,C4,C5,C6,C7,C8,
  x1,x2,x3,x4,x5,x6,x7,x8,
  y1,y2,y3,y4,y5,y6,y7,y8,
  z1,z2,z3,z4,z5,z6,z7,z8,
  u1,u2,u3,u4,u5,u6,u7,u8,
  a,b,c,la,la1,la2,la3,al,be,ga,de> := FunctionField(FF, 68);

function SplitOctonions(F);
   sc := [<1,5,1,1>, <1,6,2,1>, <1,7,3,-1>, <1,8,4,-1>, 
   		<2,3,1,-1>, <2,4,2,1>, <2,7,5,-1>, <2,8,6,1>,
   		<3,2,1,1>, <3,4,3,1>, <3,6,5,-1>, <3,8,7,-1>, 
   		<4,1,1,1>, <4,4,4,1>, <4,6,6,1>, <4,7,7,1>,
   		<5,2,2,1>, <5,3,3,1>, <5,5,5,1>, <5,8,8,1>,
   		<6,1,2,-1>, <6,3,4,-1>, <6,5,6,1>, <6,7,8,1>,
   		<7,1,3,1>, <7,2,4,-1>, <7,5,7,1>, <7,6,8,-1>,
   		<8,1,5,-1>, <8,2,6,-1>, <8,3,7,1>, <8,4,8,1>];
   return Algebra<F,8 | sc>;
end function;

OO := SplitOctonions(F);
e1 := OO.1;
e2 := OO.2;
e3 := OO.3;
e4 := OO.4;
e5 := OO.5;
e6 := OO.6;
e7 := OO.7;
e8 := OO.8;

// octonion conjugation
OC := func< oo | OO![-s[1],-s[2],-s[3],s[5],
                 s[4],-s[6],-s[7],-s[8]] 
                 where s := Eltseq(OO!oo) >; 
                 
IsRe := func< oo | &and[u eq 0 : u in [s[1],s[2],s[3],s[4]-s[5],
                   s[6],s[7],s[8]]] where s := Eltseq(OO!oo) >;
IsIm := func< oo | s[4]+s[5] eq 0 where s := Eltseq(OO!oo) >;


Nm := func< x | Eltseq(x*x@OC)[4] >;
Tc := func< x | Eltseq(x+x@OC)[4] >;

A := OO![A1,A2,A3,A4,A5,A6,A7,A8];
B := OO![B1,B2,B3,B4,B5,B6,B7,B8];
C := OO![C1,C2,C3,C4,C5,C6,C7,C8];
u := OO![u1,u2,u3,u4,u5,u6,u7,u8];
x := OO![x1,x2,x3,x4,x5,x6,x7,x8];
y := OO![y1,y2,y3,y4,y5,y6,y7,y8];
z := OO![z1,z2,z3,z4,z5,z6,z7,z8];
AA := A@OC;
BB := B@OC;
CC := C@OC;
uu := u@OC;
xx := x@OC;
yy := y@OC;
zz := z@OC;
\end{verbatim}
The way we define the function field allows
us to perform certain symbolic computations.

\begin{verbatim}
> (A * A@OC)[4];
A1*A8 + A2*A7 + A3*A6 + A4*A5
> 
> Nm(A);
A1*A8 + A2*A7 + A3*A6 + A4*A5
> 
> (A*B)[1];
A1*B5 + 2*A2*B3 + A3*B2 + A4*B1
\end{verbatim}
Next, we define the action on the Albert 
vectors and also the Dickson--Freudenthal 
determinant.
\begin{verbatim}
Acton := function(vec, mat);
   v := vec;
   m := [[mat[1],mat[2],mat[3]], 
         [mat[4],mat[5],mat[6]],
         [mat[7],mat[8],mat[9]]];
   
   if &or[not IsRe(u) : u in [v[1],v[2],v[3]]] then
      return false;
   else
      vv := [[v[1],v[6],v[5]@OC],
             [v[6]@OC,v[2],v[4]],
             [v[5],v[4]@OC,v[3]]];
      m2 := [[&+[vv[i,k]*m[k,j] 
             : k in [1..3]
             : j in [1..3]]
             : i in [1..3]];
      m1 := [[m[j,i]@OC 
             : j in [1..3]] 
             : i in [1..3]];
      mm := [[&+[m1[i,k]*m2[k,j]
             : k in [1..3]]
             : j in [1..3]]
             : i in [1..3]];
      if &or[not IsRe(u) 
             : u in [mm[1,1],mm[2,2],mm[3,3]]] then
         return "Error 1";
      elif &or [mm[2,1] ne mm[1,2]@OC, 
                mm[3,2] ne mm[2,3]@OC, 
                mm[1,3] ne mm[3,1]@OC] then
         return "Error 2";
      else
         return [mm[1,1], mm[2,2], mm[3,3],
                 mm[2,3], mm[3,1], mm[1,2]];
      end if;
   end if;
end function;

Det := function(vec); 
   v := vec;
   v1 := v[1];
   v2 := v[2];
   v3 := v[3];
   v4 := v[4];
   v5 := v[5];
   v6 := v[6];
   if &or [not IsRe(u) : u in [v[1],v[2],v[3]]] then
      return false;
   else
      return (v1*v2*v3 - v1*Nm(v4) - v2*Nm(v5) - v3*Nm(v6) + 
              Tc(v4*v5*v6))[4];
   end if;
end function;
\end{verbatim}
We may as well do some sanity check while we
are at it.
\begin{verbatim}
> Acton([a,b,c,A,B,C],[1,x,0,0,1,0,0,0,1]) eq
[a,b+a*Nm(x)+Tc(xx*C),c,A+xx*BB,B,C+a*x];
true
> Acton([a,b,c,A,B,C],[1,0,0,0,1,x,0,0,1]) eq
[a,b,c+b*Nm(x)+Tc(xx*A),A+b*x,B+xx*CC,C];
true
> Acton([a,b,c,A,B,C],[1,0,0,0,1,0,x,0,1]) eq
[a+c*Nm(x)+Tc(xx*B),b,c,A,B+c*x,C+xx*AA];
true
> Acton([a,b,c,A,B,C],[1,0,0,x,1,0,0,0,1]) eq
[a+b*Nm(x)+Tc(C*x),b,c,A,B+AA*x,C+b*xx];
true
> Acton([a,b,c,A,B,C],[1,0,0,0,1,0,0,x,1]) eq
[a,b+c*Nm(x)+Tc(A*x),c,A+c*xx,B,C+BB*x];
true
> Acton([a,b,c,A,B,C],[1,0,x,0,1,0,0,0,1]) eq
[a,b,c+a*Nm(x)+Tc(B*x),A+CC*x,B+a*xx,C];
true
> Det(Acton([a,b,c,A,B,C],[1,0,0,x,1,0,0,0,1])) eq
Det([a,b,c,A,B,C]);
true
> Det(Acton([a,b,c,A,B,C],[1,0,0,0,1,0,y,0,1])) eq
Det([a,b,c,A,B,C]);
true
> Det(Acton([a,b,c,A,B,C],[1,0,0,0,al,be,0,ga,de])) eq 
(al*de-be*ga)^2*Det([a,b,c,A,B,C]);
true
\end{verbatim}
Finally, we convert the $3\times 3$ octonionic
matrices into the
$27 \times 27$ matrices over the field, 
so that we can check
that certain groups generated by them are
what we think they should be.
\begin{verbatim}
VV := VectorSpace(FF, 27);
V := VectorSpace(F, 27);
MA27 := MatrixAlgebra(FF,27);

function CvtToVec(seq);
   return VV!([seq[i][4] : i in [1..3]] cat
              &cat[Eltseq(u) : u in 
              [seq[i] : i in [4..6]]]);
end function;

function CvtToVecSeq(seq);
   return [seq[i][4] : i in [1..3]] cat 
           &cat[Eltseq(u) : u in 
           [seq[i] : i in [4..6]]];
end function;

BASIS := [[OO!1,0,0,0,0,0], 
          [0,OO!1,0,0,0,0], 
          [0,0,OO!1,0,0,0]] cat 
         [[0,0,0,OO.i,0,0] : i in [1..8]] cat
         [[0,0,0,0,OO.i,0] : i in [1..8]] cat
         [[0,0,0,0,0,OO.i] : i in [1..8]];

function Make27DimMtx(mm);
   for u in BASIS do
      if Type(Acton(u, mm)) eq MonStgElt then
         return "Error";
      end if;
   end for;
   return MA27!&cat[CvtToVecSeq(Acton(u,mm)) : u in BASIS];
end function;
\end{verbatim}
We can now define, for instance, $\Spin_{10}^+(3)$ in the following way.
\begin{verbatim}
M := func< x | [1,x,0, 0,1,0, 0,0,1] >;
Mp := func< x | [1,0,0, 0,1,x, 0,0,1] >;
Mpp := func< x | [1,0,0, 0,1,0, x,0,1] >;
L := func< x | [1,0,0, x,1,0, 0,0,1] >;
Lp := func< x | [1,0,0, 0,1,0, 0,x,1] >;
Lpp := func< x | [1,0,x, 0,1,0, 0,0,1] >; 

E := [e1,e2,e3,e4,e5,e6,e7,e8];

GSpin10p := MatrixGroup< 27, FF | 
            [Make27DimMtx(M(x)) : x in E] cat
            [Make27DimMtx(L(x)) : x in E] >;
\end{verbatim}
It allows us to investigate the group using 
standard Magma functions. For example, 
we obtain the structure of the $G$-module, 
calculate the order, and verify that the latter
coincides with twice the order of
$\Omega_{10}^+(3)$.
\begin{verbatim}
> GM := GModule(GSpin10p);
> Constituents(GM);
[
    GModule of dimension 1 over GF(3^2),
    GModule of dimension 10 over GF(3^2),
    GModule of dimension 16 over GF(3^2)
]
[ 2, 3, 1 ]
> LMGOrder(GSpin10p);
2579025599882610278400
> 2 * #OmegaPlus(10,3);  
2579025599882610278400
\end{verbatim}
% ------------------------------------------------------------------------

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End: 
